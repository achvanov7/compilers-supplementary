-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun doBinop (l, op, r) {
    Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
        exp = memo $ eta expr ({
          [Left, {
            [s ("&&"), doBinop],
            [s ("!!"), doBinop]
          }],
          [Nona, {
            [s ("=="), doBinop],
            [s ("!="), doBinop],
            [s (">"),  doBinop],
            [s (">="), doBinop],
            [s ("<"),  doBinop],
            [s ("<="), doBinop]
          }],
          [Left, {
            [s ("+"), doBinop],
            [s ("-"), doBinop]
          }],
          [Left, {
            [s ("/"), doBinop], 
            [s ("%"), doBinop], 
            [s ("*"), doBinop]
          }]
        }, primary);

var parseStmt = memo $ eta syntax (
    kSkip {Skip}
  | kRead x = inbr[s("("), lident, s(")")] { Read (x) }
  | kWrite x = inbr[s("("), exp, s(")")] { Write (x) }
  | x = lident s[":="] e = exp { Assn (x, e) }
  | kWhile e = exp kDo body = stmt kOd { While (e, body) }
  | kDo body = stmt kWhile e = exp kOd { DoWhile (body, e) }
  | kIf e = exp kThen branchT = stmt branchF = elseBranch kFi { If (e, branchT, branchF) }
  | kFor s1 = stmt s[","] e = exp s[","] s2 = stmt kDo body = stmt kOd 
              { Seq (s1, While (e, Seq (body, s2))) }
);

var elseBranch = memo $ eta syntax (
   empty { Skip } 
  | kElse s = stmt { s }
  | kElif e = exp kThen branchT = stmt branchF = elseBranch { If (e, branchT, branchF) }
);

var stmt = memo $ eta syntax (
  parseStmt
  | head = parseStmt s[";"] tail = stmt { Seq (head, tail) } 
);

-- Public top-level parser
public parse = stmt;
